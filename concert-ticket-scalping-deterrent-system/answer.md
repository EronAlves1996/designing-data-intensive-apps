1. The system whould have two outcomes: or it gonna have a reservation on S1 and S2 and S3 gonna be available, or S2 and S3 gonna be reservated and S1 gonna be available. Based on that outcome, in the seats table (that appears like a control table, with a materializing conflicts strategy), the described seats gonna be with the status reserved or available, and the reservations gonna be created with status pending. The primary drawback for business in this scenario is that all the reservation process can be slow, because of actual serial execution of the transactions. The transaction that is executed last here gonna be stoped at the step 1.
2. We gonna have shared and exclusive lock. For the step 1, both transactions acquire a shared lock on the seats. For the second step, when making an insertion, no lock is acquired, unless the database is using index-range locks and it fallbacks to table lock. If the table is locked, the first transaction can write the insertion while the another is waiting the release of lock. The step 2 here acts like a filter and some things can be asked, like, we have any unique index on the seat_id, concert_id and status? Some logic? Thinking only on transactions, the first transaction that acquires the table lock on step 2 can go to step 3 and acquire an exclusive lock for update the seats. The second transaction can continue after the first one commits. If database dont use index-range or fallbacks to table lock, then we have a problem here: because the two transactions already acquired a shared lock on the seats table, the first transaction that goes to step 3 gonna try to promote it's lock to exclusive lock, leading to a deadlock. The database can detect deadlocks, and then abort one of the two transactions. For the index-range lock + fallback table lock, likely the concurrency problem would occur, not meeting serializable transaction specifications. For the second, a deadlock occurs and database abort one of them, while another succeeds.
3. By now, the two transaction arrives. SSI uses optimistic locking. Because of this, the two transactions can walk effortlessly from the step 1 to step 2. For the second step, this write doesn't affect any read before or after, because the predicate is maded based upon the seats table. On the step 3, one of the two transactions gonna go to this step first. When one of them pass through this step and commits, database detects that this write affected the previous result in the step 1. So, the last transaction that goes from this step is aborted. The key information here used to track are two: the index read, and the information of transaction_id that reads the index are kept within the index, or the data table read, and, in this case, the information of transaction_id that reads the data in the table is kept within the table.
4. I would choose SSI, because there's no risk of going through deadlocks, and the abortion rate can be low, when compared to 2PL.
